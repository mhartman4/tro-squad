{
  "version": 3,
  "file": "bundle.css",
  "sources": [
    "../src/App.svelte",
    "../src/BusBoard.svelte",
    "../src/Board.svelte",
    "../src/StationPicker.svelte",
    "../src/BusStopPicker.svelte"
  ],
  "sourcesContent": [
    "<script>\n  import Board from \"./Board.svelte\"\n  import BusBoard from \"./BusBoard.svelte\"\n  import StationPicker from \"./StationPicker.svelte\"\n  import BusStopPicker from \"./BusStopPicker.svelte\"\n  \n  let relevantStations = []\n  let relevantStationNames = \"\"\n  let relevantBusStops = []\n\n  let hideBusses\n  let showMapModal = false\n  let mapData = null\n  let mapInstance = null\n  let stationSearching = false\n  let busSearching = false\n  \n  // Marker management state\n  let stopMarkersLayer = null\n  let visibleMarkers = new Map() // Map<stopKey, marker> where stopKey is \"Lat,Lon\"\n  let mapUpdateDebounceTimer = null\n  let mapMoveHandler = null\n  let mapZoomHandler = null\n\n  \n  if (localStorage.getItem(\"relevantStations\")) {\n      relevantStations = JSON.parse(localStorage.getItem(\"relevantStations\"));\n  }\n\n  if (localStorage.getItem(\"relevantBusStops\")) {\n      relevantBusStops = JSON.parse(localStorage.getItem(\"relevantBusStops\"));\n  }\n\n  if (localStorage.getItem(\"hideBusses\")) {\n      hideBusses = JSON.parse(localStorage.getItem(\"hideBusses\"));\n  }\n  else {\n    hideBusses = true\n    localStorage.setItem(\"hideBusses\", JSON.stringify(hideBusses));\n  }\n  \n  $: relevantStationNames = relevantStations.map(station => station.Name)\n  $: relevantBusStops = relevantBusStops\n  \n  // Update map popups when relevantBusStops changes (only if map is already initialized)\n  $: if (mapInstance && mapData && showMapModal) {\n    setTimeout(() => {\n      updateMapPopups()\n    }, 50)\n  }\n  \n  // Initialize map when modal opens\n  $: if (showMapModal && mapData && !mapInstance) {\n    setTimeout(() => {\n      initMap()\n    }, 200)\n  }\n\n  const toggle = (station) => { \n    if (relevantStations && station) {\n      let i = relevantStationNames.indexOf(station.Name)\n      if (i > -1) {\n        relevantStations = [...relevantStations.slice(0, i), ...relevantStations.slice(i + 1)];\n        gtag('event', 'removeStation', {\"station\": station, \"button\": \"top-button\"})\n      }\n      else {        \n        relevantStations = [...relevantStations, station]\n      }\n      localStorage.setItem(\"relevantStations\", JSON.stringify(relevantStations));\n    }\n  }\n\n  const toggleBusStop = (stop) => { \n    console.log(\"Toggle\")   \n    if (relevantBusStops && stop) {\n      let i = relevantBusStops.indexOf(stop)\n      console.log(i)\n      if (i > -1) {\n        console.log(\"Remove stop\")        \n        relevantBusStops = [...relevantBusStops.slice(0, i), ...relevantBusStops.slice(i + 1)];\n        gtag('event', 'removeBusStop', {\"stop\": stop, \"button\": \"top-button\"})\n      }\n      else {\n        relevantBusStops = [...relevantBusStops, stop]\n      }\n      localStorage.setItem(\"relevantBusStops\", JSON.stringify(relevantBusStops));\n    }\n  }\n\n  const addBusStopFromMap = (stop) => {\n    if (relevantBusStops && stop) {\n      const stopKey = stop.Name + \" (\" + stop.StopID + \")\"\n      const existingStop = relevantBusStops.find(s => s.Name + \" (\" + s.StopID + \")\" === stopKey)\n      \n      if (!existingStop) {\n        relevantBusStops = [...relevantBusStops, stop]\n        localStorage.setItem(\"relevantBusStops\", JSON.stringify(relevantBusStops));\n        gtag('event', 'addBusStop', {\"stop\": stop, \"source\": \"map\"})\n        \n        // Update popup after adding\n        if (mapInstance) {\n          updateMapPopups()\n        }\n      }\n    }\n  }\n\n  const isStopAdded = (stop) => {\n    if (!relevantBusStops || !stop) return false\n    const stopKey = stop.Name + \" (\" + stop.StopID + \")\"\n    return relevantBusStops.some(s => s.Name + \" (\" + s.StopID + \")\" === stopKey)\n  }\n\n  // Get stop key for marker tracking\n  const getStopKey = (stop) => {\n    return `${stop.Lat},${stop.Lon}`\n  }\n\n  // Filter stops within map bounds (with buffer)\n  const getStopsInBounds = (bounds, buffer = 0.2) => {\n    if (!mapData || !mapData.allStops) return []\n    \n    // Expand bounds by buffer percentage\n    const latDiff = bounds.getNorth() - bounds.getSouth()\n    const lngDiff = bounds.getEast() - bounds.getWest()\n    \n    const expandedBounds = L.latLngBounds([\n      [bounds.getSouth() - latDiff * buffer, bounds.getWest() - lngDiff * buffer],\n      [bounds.getNorth() + latDiff * buffer, bounds.getEast() + lngDiff * buffer]\n    ])\n    \n    return mapData.allStops.filter(stop => {\n      if (!stop.Lat || !stop.Lon) return false\n      return expandedBounds.contains([stop.Lat, stop.Lon])\n    })\n  }\n\n  // Create a marker for a stop\n  const createStopMarker = (stop) => {\n    const isAdded = isStopAdded(stop)\n    const stopColor = isAdded ? '#78a6ee' : '#FF0000'\n    \n    const stopIcon = L.divIcon({\n      className: 'custom-marker',\n      html: `<div style=\"background-color: ${stopColor}; width: 20px; height: 20px; border-radius: 50%; border: 2px solid white; box-shadow: 0 2px 4px rgba(0,0,0,0.3);\"></div>`,\n      iconSize: [20, 20],\n      iconAnchor: [10, 10]\n    })\n    \n    const popupContent = createStopPopupContent(stop)\n    const marker = L.marker([stop.Lat, stop.Lon], {\n      icon: stopIcon,\n      title: stop.Name\n    }).bindPopup(popupContent)\n    \n    return marker\n  }\n\n  // Update visible markers based on current map bounds\n  const updateVisibleMarkers = () => {\n    if (!mapInstance || !mapData || !stopMarkersLayer) return\n    \n    const bounds = mapInstance.getBounds()\n    const stopsInBounds = getStopsInBounds(bounds, 0.2)\n    const stopsInBoundsKeys = new Set(stopsInBounds.map(stop => getStopKey(stop)))\n    \n    // Remove markers that are no longer in bounds\n    const keysToRemove = []\n    visibleMarkers.forEach((marker, stopKey) => {\n      if (!stopsInBoundsKeys.has(stopKey)) {\n        stopMarkersLayer.removeLayer(marker)\n        keysToRemove.push(stopKey)\n      }\n    })\n    keysToRemove.forEach(key => visibleMarkers.delete(key))\n    \n    // Add markers for stops that are now in bounds\n    stopsInBounds.forEach(stop => {\n      const stopKey = getStopKey(stop)\n      if (!visibleMarkers.has(stopKey)) {\n        const marker = createStopMarker(stop)\n        stopMarkersLayer.addLayer(marker)\n        visibleMarkers.set(stopKey, marker)\n      }\n    })\n  }\n\n  const createStopPopupContent = (stop) => {\n    const isAdded = isStopAdded(stop)\n    const buttonText = isAdded ? \"Added\" : \"Add\"\n    const buttonStyle = isAdded \n      ? \"background-color: #78a6ee; color: white;\"\n      : \"background-color: #394d76; color: white;\"\n    \n    // Store stop data in data attribute for event handling\n    const stopData = encodeURIComponent(JSON.stringify(stop))\n    \n    return `\n      <div style=\"text-align: center; padding: 5px; font-family: 'VT323', monospace;\">\n        <div style=\"margin-bottom: 8px; font-weight: bold;\">${stop.Name}</div>\n        <button \n          class=\"add-stop-btn\" \n          data-stop='${stopData}'\n          style=\"${buttonStyle} border: none; border-radius: 5px; padding: 5px 15px; cursor: pointer; font-family: 'VT323', monospace;\"\n        >\n          ${buttonText}\n        </button>\n      </div>\n    `\n  }\n\n  const updateMapPopups = () => {\n    if (!mapInstance || !mapData || !stopMarkersLayer) return\n    \n    // Update all visible stop markers' popups and icons\n    visibleMarkers.forEach((marker, stopKey) => {\n      const [lat, lon] = stopKey.split(',').map(Number)\n      const stop = mapData.allStops.find(s => \n        Math.abs(s.Lat - lat) < 0.0001 && \n        Math.abs(s.Lon - lon) < 0.0001\n      )\n      if (stop) {\n        // Update popup content\n        marker.setPopupContent(createStopPopupContent(stop))\n        \n        // Update marker color based on whether stop is added\n        const isAdded = isStopAdded(stop)\n        const stopColor = isAdded ? '#78a6ee' : '#FF0000'\n        const stopIcon = L.divIcon({\n          className: 'custom-marker',\n          html: `<div style=\"background-color: ${stopColor}; width: 20px; height: 20px; border-radius: 50%; border: 2px solid white; box-shadow: 0 2px 4px rgba(0,0,0,0.3);\"></div>`,\n          iconSize: [20, 20],\n          iconAnchor: [10, 10]\n        })\n        marker.setIcon(stopIcon)\n      }\n    })\n    \n    // Re-attach event listeners after updating popups\n    setTimeout(() => {\n      attachPopupButtonListeners()\n    }, 100)\n  }\n\n  let popupButtonHandler = null\n\n  const attachPopupButtonListeners = () => {\n    // Remove existing listener if any\n    const mapElement = document.getElementById('map')\n    if (mapElement && popupButtonHandler) {\n      mapElement.removeEventListener('click', popupButtonHandler)\n    }\n    \n    // Add new listener\n    popupButtonHandler = (e) => {\n      if (e.target.classList.contains('add-stop-btn')) {\n        const stopData = e.target.getAttribute('data-stop')\n        if (stopData) {\n          try {\n            const stop = JSON.parse(decodeURIComponent(stopData))\n            addBusStopFromMap(stop)\n          } catch (err) {\n            console.error('Error parsing stop data:', err)\n          }\n        }\n      }\n    }\n    \n    if (mapElement) {\n      mapElement.addEventListener('click', popupButtonHandler)\n    }\n  }\n\n  const toggleBusMode = () => {\n    hideBusses = !hideBusses\n    localStorage.setItem(\"hideBusses\", JSON.stringify(hideBusses));\n  }\n\n  const findClosestStop = async () => {\n    if (navigator.geolocation) {\n      navigator.geolocation.getCurrentPosition(async (position) => {\n        const userLat = position.coords.latitude\n        const userLng = position.coords.longitude\n        \n        // Fetch all bus stops\n        const response = await fetch(`./bus_stops`)\n        const allStops = await response.json()\n        \n        // Calculate distance using Haversine formula\n        const calculateDistance = (lat1, lon1, lat2, lon2) => {\n          const R = 6371 // Earth's radius in km\n          const dLat = (lat2 - lat1) * Math.PI / 180\n          const dLon = (lon2 - lon1) * Math.PI / 180\n          const a = \n            Math.sin(dLat / 2) * Math.sin(dLat / 2) +\n            Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *\n            Math.sin(dLon / 2) * Math.sin(dLon / 2)\n          const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a))\n          return R * c\n        }\n        \n        // Calculate distance for each stop and sort\n        const stopsWithDistance = allStops\n          .filter(stop => stop.Lat && stop.Lon) // Only stops with coordinates\n          .map(stop => ({\n            ...stop,\n            distance: calculateDistance(userLat, userLng, stop.Lat, stop.Lon)\n          }))\n          .sort((a, b) => a.distance - b.distance)\n        \n        // Get the 7th closest stop's distance to determine zoom level (shows ~5-10 stops)\n        const referenceDistance = (stopsWithDistance[6] && stopsWithDistance[6].distance) || 1 // km\n        // Calculate zoom level: closer stops need higher zoom, further need lower\n        // Rough formula: zoom 15 = ~0.5km, zoom 14 = ~1km, zoom 13 = ~2km\n        let zoomLevel = 14\n        if (referenceDistance < 0.5) {\n          zoomLevel = 15\n        } else if (referenceDistance < 1) {\n          zoomLevel = 14\n        } else if (referenceDistance < 2) {\n          zoomLevel = 13\n        } else {\n          zoomLevel = 12\n        }\n        \n        console.log(stopsWithDistance)\n        \n        // Store map data and show modal (all stops, not just 10)\n        mapData = {\n          userLocation: { lat: userLat, lng: userLng },\n          allStops: stopsWithDistance,\n          zoomLevel: zoomLevel\n        }\n        showMapModal = true\n      }, (error) => {\n        console.error(\"Error getting location:\", error)\n      })\n    } else {\n      console.error(\"Geolocation is not supported by this browser\")\n    }\n  }\n\n  const closeMapModal = () => {\n    showMapModal = false\n    \n    // Clean up map event handlers\n    if (mapInstance) {\n      if (mapMoveHandler) {\n        mapInstance.off('moveend', mapMoveHandler)\n        mapMoveHandler = null\n      }\n      if (mapZoomHandler) {\n        mapInstance.off('zoomend', mapZoomHandler)\n        mapZoomHandler = null\n      }\n      mapInstance.remove()\n      mapInstance = null\n    }\n    \n    // Clean up debounce timer\n    if (mapUpdateDebounceTimer) {\n      clearTimeout(mapUpdateDebounceTimer)\n      mapUpdateDebounceTimer = null\n    }\n    \n    // Clean up marker layer and tracking\n    if (stopMarkersLayer) {\n      stopMarkersLayer.clearLayers()\n      stopMarkersLayer = null\n    }\n    visibleMarkers.clear()\n    \n    mapData = null\n    \n    // Clean up event listener\n    const mapElement = document.getElementById('map')\n    if (mapElement && popupButtonHandler) {\n      mapElement.removeEventListener('click', popupButtonHandler)\n      popupButtonHandler = null\n    }\n  }\n\n  const initMap = () => {\n    if (!mapData) return\n    \n    // Wait for Leaflet to be available\n    if (!window.L) {\n      // Check if script is already being loaded\n      if (document.querySelector('script[src*=\"leaflet\"]')) {\n        // Wait for it to load\n        const checkLeaflet = setInterval(() => {\n          if (window.L) {\n            clearInterval(checkLeaflet)\n            createMap()\n          }\n        }, 100)\n        return\n      }\n      // Leaflet should already be loaded from HTML, but wait a bit\n      setTimeout(() => {\n        if (window.L) {\n          createMap()\n        }\n      }, 100)\n      return\n    }\n    \n    createMap()\n  }\n\n  const createMap = () => {\n    if (!mapData || !window.L) return\n    \n    const mapElement = document.getElementById('map')\n    if (!mapElement) return\n    \n    // Clear existing map if it exists\n    if (mapInstance) {\n      mapInstance.remove()\n      mapInstance = null\n    }\n    \n    // Reset marker tracking\n    visibleMarkers.clear()\n    stopMarkersLayer = null\n    \n    // Create map centered on user location with calculated zoom level\n    const zoomLevel = mapData.zoomLevel || 14\n    mapInstance = L.map(mapElement).setView(\n      [mapData.userLocation.lat, mapData.userLocation.lng],\n      zoomLevel\n    )\n    \n    // Add dark mode tile layer (CartoDB Dark Matter)\n    L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {\n      attribution: '¬© OpenStreetMap contributors ¬© CARTO',\n      maxZoom: 19\n    }).addTo(mapInstance)\n    \n    // Create pin icon for user location (blue)\n    const userIcon = L.icon({\n      iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-blue.png',\n      shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/0.7.7/images/marker-shadow.png',\n      iconSize: [25, 41],\n      iconAnchor: [12, 41],\n      popupAnchor: [1, -34],\n      shadowSize: [41, 41]\n    })\n    \n    // Add user location marker\n    const userMarker = L.marker([mapData.userLocation.lat, mapData.userLocation.lng], {\n      icon: userIcon,\n      title: 'Your Location'\n    }).addTo(mapInstance).bindPopup('Your Location')\n    \n    // Create LayerGroup for stop markers\n    stopMarkersLayer = L.layerGroup().addTo(mapInstance)\n    \n    // Add initial markers for stops in viewport\n    updateVisibleMarkers()\n    \n    // Attach event listeners for popup buttons\n    attachPopupButtonListeners()\n    \n    // Add debounced event handlers for map movement\n    const debouncedUpdateMarkers = () => {\n      if (mapUpdateDebounceTimer) {\n        clearTimeout(mapUpdateDebounceTimer)\n      }\n      mapUpdateDebounceTimer = setTimeout(() => {\n        updateVisibleMarkers()\n      }, 250)\n    }\n    \n    mapMoveHandler = debouncedUpdateMarkers\n    mapZoomHandler = debouncedUpdateMarkers\n    \n    mapInstance.on('moveend', mapMoveHandler)\n    mapInstance.on('zoomend', mapZoomHandler)\n    \n    // Center map on user location\n    mapInstance.setView([mapData.userLocation.lat, mapData.userLocation.lng], 14)\n  }\n  \n</script>\n\n<div class=\"relevant-stations\">\n  {#each relevantStations as station}\n    <span class=\"station\" on:click={() => toggle(station)}>{station.Name.length > 20 ? station.Name.substring(0,20) : station.Name}\n    </span>\n  {/each}\n</div>\n\n{#if !hideBusses}\n  <div class=\"relevant-stations\">\n    {#each relevantBusStops as stop}\n      <span class=\"bus-stop\" on:click={() => toggleBusStop(stop)}>{stop.Name + \" (\" + stop.StopID + \")\"}</span>\n    {/each}\n  </div>\n{/if}\n<StationPicker bind:relevantStations={relevantStations} bind:hideBusses={hideBusses} bind:isSearching={stationSearching}/>\n\n{#if !hideBusses}\n  <BusStopPicker bind:relevantBusStops={relevantBusStops} bind:isSearching={busSearching}/>\n  <button class=\"find-closest-stop\" on:click={findClosestStop}>üìç Bus stop map</button>\n{/if}\n\n<Board bind:relevantStationNames={relevantStationNames} bind:hideBusses={hideBusses} showMapModal={showMapModal} isSearching={stationSearching || busSearching} />\n{#if !hideBusses}\n  <BusBoard bind:relevantBusStops={relevantBusStops}/>\n{/if}\n\n<br>\n<button id=\"hide-busses\" on:click={() => toggleBusMode()}>{hideBusses ? \"üöå Show Busses too!\" : \"üöå Hide Busses\"}</button>\n\n{#if showMapModal}\n  <div class=\"map-modal-overlay\" on:click={closeMapModal}>\n    <div class=\"map-modal\" on:click|stopPropagation>\n      <button class=\"map-close\" on:click={closeMapModal}>√ó</button>\n      <div id=\"map\" class=\"map-container\"></div>\n    </div>\n  </div>\n{/if}\n\n<style>\n  .station {\n    background-color: #e5e1e1;;\n    border-radius: 5px;\n    padding: 2px;\n    margin: 2px;\n    text-align: center;\n    color: #ff5441;\n  }\n\n  .bus-stop {\n    background-color: #78a6ee;;\n    border-radius: 5px;\n    padding: 2px;\n    margin: 2px;\n    text-align: center;\n    color: #394d76;\n/*    font-family: \"Open Sans\";*/\n/*    font-size: 12px;*/\n  }\n\n  .relevant-stations {\n    margin: 5px;\n    display: flex;\n    width: 100%;\n  }\n\n  #hide-busses {\n    background-color: #394d76;\n    color: white;\n    border-width: 0px;\n  }\n\n  .find-closest-stop {\n    font-size: 14px;\n    padding: 4px 8px;\n    margin: 5px 0;\n    background-color: #394d76;\n    color: white;\n    border-width: 0px;\n  }\n\n  .map-modal-overlay {\n    position: fixed;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n    background-color: rgba(0, 0, 0, 0.9);\n    display: flex;\n    justify-content: center;\n    align-items: center;\n    z-index: 1000;\n  }\n\n  .map-modal {\n    position: relative;\n    width: 100%;\n    height: 100%;\n    background-color: #21292f;\n    padding: 0;\n    border: none;\n    border-radius: 0;\n  }\n\n  .map-close {\n    position: absolute;\n    top: 10px;\n    right: 10px;\n    background-color: #394d76;\n    color: white;\n    border: none;\n    border-radius: 50%;\n    width: 40px;\n    height: 40px;\n    font-size: 24px;\n    cursor: pointer;\n    z-index: 1001;\n    display: flex;\n    align-items: center;\n    justify-content: center;\n  }\n\n  .map-close:hover {\n    background-color: #5977b5;\n  }\n\n  .map-container {\n    width: 100%;\n    height: 100%;\n    border-radius: 0;\n  }\n\n  :global(.custom-marker) {\n    background: transparent;\n    border: none;\n  }\n</style>\n",
    "<script>\n  \n  let busPredictions;\n  export let relevantBusStops;\n\n  const getBusPredictions = async (stops) => {\n    const response = await fetch(`./bus_predictions/` + JSON.stringify(stops.map(stop => {return stop.StopID})))\n    busPredictions = await response.json()\n  }\n  \n  $: getBusPredictions(relevantBusStops)\n\n\n</script>\n{#if relevantBusStops}\n  {#each relevantBusStops as stop}\n    <h1 class=\"board-stop\">üöå {stop.Name}<span class=\"stop-id\">{stop.StopID}</span></h1>\n    \n    {#if busPredictions && busPredictions[stop.StopID]}\n      <table>\n        {#each busPredictions[stop.StopID] as bus}\n          <tr class=\"bus\">\n            <td><span class=\"route\">{bus.RouteID}</span></td>\n            <td>{bus.DirectionText}&nbsp;&nbsp;&nbsp;&nbsp;</td>\n            <td>{bus.Minutes}</td>\n          </tr>\n        {/each}\n      </table>\n    {:else}\n      Loading...\n    {/if}\n  {/each}\n{/if}\n\n<style>\n  .board-stop {\n    text-transform: uppercase;\n    color: #78a6ee;\n    margin-bottom: 3px;\n    font-size: 28px;\n  }\n  .bus {\n    color: white;\n    font-size: 20px;\n  }\n  .stop-id {\n    background-color: #78a6ee;\n    color: #394d76;\n    margin: 2px;\n    border-radius: 6px;\n    padding: 2px;\n    font-size: 18px;\n  }\n  \n  .route {\n    color: white;\n    padding: 0px 7px;\n    background-color: rgb(157 31 26);\n  }\n  .stop-number {\n    background-color: white;\n    color: rgb(43 45 93);\n  }\n</style>",
    "<script>\n  import { onMount } from \"svelte\"\n  let trainPredictions, secondsSinceLastUpdate, updatedAt;\n  export let relevantStationNames;\n  export let hideBusses\n  export let showMapModal = false\n  export let isSearching = false\n\n  onMount(async () => {\n    getTrainPredictions()\n    setInterval(function(){\n      secondsSinceLastUpdate = Math.round((new Date() - updatedAt) / 1000)\n      // Don't refresh if map modal is open or user is searching\n      if (secondsSinceLastUpdate >= 45 && !showMapModal && !isSearching) {\n        refresh()\n      }\n    }, 1000);\n  })\n\n  const getTrainPredictions = async () => {\n    const response = await fetch(`./train_predictions`)\n    trainPredictions = await response.json()\n    updatedAt = await new Date()\n    secondsSinceLastUpdate = Math.round((new Date() - updatedAt) / 1000)\n  }\n\n  const refresh = () => {\n    gtag('event', 'refresh', {})\n    location.reload();\n  }\n\n</script>\n<div>\n  <a href=\"#\" on:click={() => refresh() }>üîÑ</a>\n  last updated {secondsSinceLastUpdate} seconds ago\n</div>\n{#if relevantStationNames}\n  {#each relevantStationNames as station}\n    <h1 class=\"board-station\">{hideBusses ? \"\" : \"üöÜ\"} {station.length > 20 ? station.substring(0,20) : station}</h1>\n    {#if trainPredictions}\n      <table>\n      {#each trainPredictions as train}\n        {#if train.LocationName == station && train.Destination != \"ssenger\"}\n          <tr class=\"train\">\n            <td><span class=\"dot {train.Line}\"></span></td>\n            <td>{train.Destination}&nbsp;&nbsp;&nbsp;&nbsp;</td>\n            <td>{train.Min}</td>\n          </tr>\n        {/if}\n      {/each}\n      </table>\n    {:else}\n      Loading...\n    {/if}\n  {/each}\n{/if}\n\n\n\n<style>\n  .board-station {\n    text-transform: uppercase;\n    color: #FF5442;\n    margin-bottom: 3px;\n  }\n  .train {\n    text-transform: uppercase;\n    color: #FFF068;\n    font-size: 22px;\n  }\n</style>",
    "<script>\n  import { onMount } from \"svelte\"\n  let allStations\n  let query = \"\"\n  let searchResults = []\n  let placeholder = \"Add train stations\"\n  export let relevantStations, hideBusses\n  \n  // Export search state so parent can check if user is searching\n  export let isSearching = false\n  $: isSearching = query.length > 0\n  $: relevantStationNames = relevantStations.map(station => station.Name)\n  // $: placeholder = relevantStations.length == 0 ? \"Add stations\" : \"\"\n  onMount(async () => {\n    allStations = await getStations()\n    searchResults = []\n  })\n\n  const getStations = async () => {\n    const response = await fetch(`./stations`)\n    return response.json()\n  }\n\n  const searchStations = () => {\n    if (query == \"\") {\n      return searchResults = []\n    }\n    else {\n      return searchResults = allStations.filter(station => {\n        gtag('event', 'stationSearch', {\"query\": query})\n        let stationName = station.Name.toLowerCase().replace(\"'\", \"\");\n        return stationName.includes(query.toLowerCase().replace(\"'\", \"\"))\n      })\n    } \n    \n  }\n\n  const toggle = (station) => { \n    if (relevantStations && station) {\n      let i = relevantStationNames.indexOf(station.Name)\n      if (i > -1) {\n        relevantStations = [...relevantStations.slice(0, i), ...relevantStations.slice(i + 1)];\n      }\n      else {        \n        relevantStations = [...relevantStations, station]\n      }\n      localStorage.setItem(\"relevantStations\", JSON.stringify(relevantStations));\n      gtag('event', 'addStation', {\"station\": station})\n    }\n    query = \"\"\n    searchStations()\n  }\n\n\n\n  \n</script>\n<input type=\"text\" id=\"search\" placeholder=\"{hideBusses ? \"\" : \"üöÜ\"} {placeholder}\" bind:value={query} on:input={searchStations}>\n<table>\n{#each searchResults as station}\n    <tr class=\"station\">\n      <td>\n        <button on:click={() => toggle(station)} class=\"{relevantStationNames.indexOf(station.Name) > -1 ? \"is-relevant\" : \"\"}\" autocomplete=\"off\">\n          {station.Name.length > 20 ? station.Name.substring(0,20) : station.Name}\n          {#each station.Lines as line}\n            {#if line}\n              <span class=\"dot {line}\"></span>\n            {/if}\n          {/each}\n        </button>\n      </td>\n      <!-- {JSON.stringify(station)} -->\n    </tr>\n  \n{/each}\n</table>    \n\n\n\n<style>\n  \n  .station {\n    text-transform: uppercase;\n    color: #FFF068;\n    margin-bottom: 3px;\n  }\n  .lines {\n    text-align: left;\n  }\n  #search {\n    text-transform: uppercase;\n    color: #FF5442;\n    font-size: 22px;\n    background-color: #21292f;\n    width: 100%;\n    border-width: 1px;\n    border-radius: 10px;\n  }\n  ::placeholder {\n    color: #FFF068;\n    opacity: 1; \n  }\n  .is-relevant {\n    background-color: #ffffffeb;\n    color: black;\n  }\n</style>",
    "<script>\n  import { onMount } from \"svelte\"\n  let allBusStops\n  let query = \"\"\n  let debouncedQuery = \"\"\n  let searchResults = []\n  let placeholder = \"Add bus stops\"\n  let busPredictions\n  export let relevantBusStops\n  let relevantBusStopSet = new Set()\n  \n  // Export search state so parent can check if user is searching\n  export let isSearching = false\n  $: isSearching = query.length > 0\n  \n  // Debounce query updates\n  let debounceTimer\n  $: {\n    clearTimeout(debounceTimer)\n    debounceTimer = setTimeout(() => {\n      debouncedQuery = query\n    }, 150)\n  }\n  \n  // Update Set for O(1) relevance checks\n  $: relevantBusStopSet = new Set(\n    relevantBusStops.map(stop => stop.Name + \" (\" + stop.StopID + \")\")\n  )\n  \n  onMount(async () => {\n    allBusStops = await getBusStops()\n    searchResults = []\n  })\n\n  const getBusStops = async () => {\n    const response = await fetch(`./bus_stops`)\n    let stops = await response.json()\n    stops.forEach(s => {\n      s.stopNameForSearch = s.Name.toLowerCase().replace(\"'\", \"\") + \" (\" + s.StopID + \")\";\n    })\n    return stops\n  }\n\n  // Normalize query once\n  const normalizeQuery = (q) => {\n    return q.toLowerCase().replace(\"'\", \"\")\n  }\n\n  // Check if all query characters appear in order (fuzzy match)\n  const fuzzyMatch = (text, query) => {\n    let textIndex = 0\n    let queryIndex = 0\n    \n    while (textIndex < text.length && queryIndex < query.length) {\n      if (text[textIndex] === query[queryIndex]) {\n        queryIndex++\n      }\n      textIndex++\n    }\n    \n    return queryIndex === query.length\n  }\n\n  // Check if all words in query appear in text (word-order independent)\n  const wordOrderIndependentMatch = (text, query) => {\n    const queryWords = query.trim().split(/\\s+/).filter(w => w.length > 0)\n    if (queryWords.length === 0) return false\n    \n    // Check if all words appear somewhere in the text\n    return queryWords.every(word => {\n      // Try exact word match first\n      if (text.includes(word)) return true\n      // Fall back to fuzzy character-in-order match for each word\n      return fuzzyMatch(text, word)\n    })\n  }\n\n  // Calculate simple edit distance for typo handling (only for short queries)\n  const simpleEditDistance = (text, query) => {\n    if (query.length > 10) return Infinity // Skip for long queries to keep it fast\n    \n    const m = text.length\n    const n = query.length\n    const dp = Array(m + 1).fill(null).map(() => Array(n + 1).fill(0))\n    \n    for (let i = 0; i <= m; i++) dp[i][0] = i\n    for (let j = 0; j <= n; j++) dp[0][j] = j\n    \n    for (let i = 1; i <= m; i++) {\n      for (let j = 1; j <= n; j++) {\n        if (text[i - 1] === query[j - 1]) {\n          dp[i][j] = dp[i - 1][j - 1]\n        } else {\n          dp[i][j] = 1 + Math.min(\n            dp[i - 1][j],     // deletion\n            dp[i][j - 1],     // insertion\n            dp[i - 1][j - 1]  // substitution\n          )\n        }\n      }\n    }\n    \n    return dp[m][n]\n  }\n\n  // Score a match: higher is better\n  const scoreMatch = (stop, normalizedQuery) => {\n    const searchText = stop.stopNameForSearch\n    \n    // Tier 1: Exact substring match (highest priority)\n    if (searchText.includes(normalizedQuery)) {\n      // Bonus for matches at the start\n      if (searchText.startsWith(normalizedQuery)) {\n        return 100\n      }\n      return 90\n    }\n    \n    // Tier 1.5: Word-order independent match (all words present, any order)\n    if (wordOrderIndependentMatch(searchText, normalizedQuery)) {\n      // Score based on word positions and how close they are\n      const queryWords = normalizedQuery.trim().split(/\\s+/).filter(w => w.length > 0)\n      let score = 80\n      \n      // Bonus if words appear in the same order as query\n      let lastIndex = -1\n      let wordsInOrder = true\n      for (const word of queryWords) {\n        const index = searchText.indexOf(word)\n        if (index === -1) {\n          wordsInOrder = false\n          break\n        }\n        if (index < lastIndex) {\n          wordsInOrder = false\n          break\n        }\n        lastIndex = index\n      }\n      \n      if (wordsInOrder) {\n        score = 85 // Slight bonus for words in order\n      }\n      \n      return score\n    }\n    \n    // Tier 2: Fuzzy match (characters in order)\n    if (fuzzyMatch(searchText, normalizedQuery)) {\n      // Score based on how close the match is (fewer gaps = higher score)\n      let score = 70\n      let textIndex = 0\n      let queryIndex = 0\n      let gaps = 0\n      \n      while (textIndex < searchText.length && queryIndex < normalizedQuery.length) {\n        if (searchText[textIndex] === normalizedQuery[queryIndex]) {\n          queryIndex++\n        } else {\n          gaps++\n        }\n        textIndex++\n      }\n      \n      // Reduce score based on gaps (but keep it above typo scores)\n      score = Math.max(50, score - Math.min(gaps * 2, 20))\n      return score\n    }\n    \n    // Tier 3: Typo handling (edit distance) - only for short queries\n    if (normalizedQuery.length <= 10) {\n      const distance = simpleEditDistance(searchText, normalizedQuery)\n      const maxDistance = Math.floor(normalizedQuery.length / 3) // Allow ~33% errors\n      \n      if (distance <= maxDistance) {\n        // Score inversely proportional to distance\n        return Math.max(10, 40 - (distance * 5))\n      }\n    }\n    \n    return 0 // No match\n  }\n\n  // Perform search with debounced query\n  $: {\n    if (debouncedQuery === \"\") {\n      searchResults = []\n    } else {\n      const normalizedQuery = normalizeQuery(debouncedQuery)\n      \n      // Track search event once (not per item)\n      if (normalizedQuery.length > 0) {\n        gtag('event', 'busStopSearch', {\"query\": debouncedQuery})\n      }\n      \n      // Score and filter all stops\n      const scoredResults = allBusStops\n        .map(stop => ({\n          stop,\n          score: scoreMatch(stop, normalizedQuery)\n        }))\n        .filter(item => item.score > 0)\n        .sort((a, b) => b.score - a.score) // Sort by score descending\n        .slice(0, 50) // Limit to top 50 results\n        .map(item => item.stop) // Extract just the stops\n      \n      searchResults = scoredResults\n    }\n  }\n\n  const toggle = (stop) => { \n    if (relevantBusStops && stop) {\n      const stopKey = stop.Name + \" (\" + stop.StopID + \")\"\n      let i = relevantBusStops.findIndex(s => s.Name + \" (\" + s.StopID + \")\" === stopKey)\n      if (i > -1) {\n        relevantBusStops = [...relevantBusStops.slice(0, i), ...relevantBusStops.slice(i + 1)];\n      }\n      else {        \n        relevantBusStops = [...relevantBusStops, stop]\n      }\n      localStorage.setItem(\"relevantBusStops\", JSON.stringify(relevantBusStops));\n      gtag('event', 'addBusStop', {\"stop\": stop})\n    }\n    query = \"\"\n  }\n\n\n\n  \n</script>\n<input type=\"text\" id=\"search\" placeholder=\"üöå {placeholder}\" bind:value={query}>\n<table>\n{#each searchResults as stop}\n    <tr class=\"stop\">\n      <td>\n        <button on:click={() => toggle(stop)} class=\"stop-result {relevantBusStopSet.has(stop.Name + \" (\" + stop.StopID + \")\") ? \"is-relevant\" : \"\"}\" autocomplete=\"off\">\n          <span>{stop.Name}</span>\n          <div>\n            <span class=\"stop-id\">{stop.StopID}</span>\n          </div>\n          <div class=\"routes\">\n            {#each stop.Routes as route}\n              {#if !route.includes(\"*\") && !route.includes(\"/\")}\n                <span class=\"route\">{route}</span>\n              {/if}\n            {/each}\n          </div>\n        </button>\n      </td>\n      <!-- {JSON.stringify(station)} -->\n    </tr>\n  \n{/each}\n</table>    \n\n\n\n<style>\n  \n  .stop {\n    text-transform: uppercase;\n    color: #FFF068;\n    margin-bottom: 3px;\n/*    font-family: \"Open Sans\";*/\n  }\n  #search {\n    text-transform: uppercase;\n/*    font-family: \"Open Sans\";*/\n    color: #78a6ee;\n    font-size: 22px;\n    background-color: #21292f;\n    width: 100%;\n    border-width: 1px;\n    border-radius: 10px;\n  }\n  ::placeholder {\n    color: #78a6ee;\n    opacity: 1; \n  }\n  .is-relevant {\n    background-color: #ffffffeb;\n    color: black;\n  }\n  .route {\n    background-color: red;\n    color: white;\n    margin-right: 2px;\n    border-radius: 6px;\n    padding: 2px;\n  }\n  .stop-id {\n    background-color: #5977b5;\n    color: white;\n    margin: 2px;\n    border-radius: 6px;\n    padding: 2px;\n    font-size: 18px;\n  }\n  .stop-result {\n    text-align: left;\n    display: flex;\n    flex-direction: column;\n    align-items: flex-start;\n    width: 100%;\n    gap: 4px;\n  }\n  .routes {\n    display: flex;\n    flex-wrap: wrap;\n    gap: 2px;\n  }\n</style>"
  ],
  "names": [],
  "mappings": "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"
}